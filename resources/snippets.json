{
    "abstract": "abstract class ClassName { }",
    "as": "Type variable = someValue as Type;",
    "async": "public async Task MethodName() { }",
    "await": "await Task.Delay(1000);",
    "base": "base.MethodName();",
    "break": "break;",
    "case": "case value:\n\t// code\n\tbreak;",
    "catch": "catch (Exception ex) {\n\t// code\n}",
    "class": "class ClassName { }",
    "const": "const int ConstantValue = 10;",
    "continue": "continue;",
    "default": "default:\n\t// code\n\tbreak;",
    "delegate": "public delegate void DelegateName();",
    "dynamic": "dynamic variable = GetDynamicValue();",
    "do": "do {\n\t// code\n} while (condition);",
    "double": "double variable = 10.5;",
    "else": "else {\n\t// code\n}",
    "enum": "enum EnumName { Value1, Value2 }",
    "event": "public event EventHandler EventName;",
    "explicit": "public static explicit operator TypeName(int value) { return new TypeName(value); }",
    "extern": "extern void MethodName();",
    "false": "bool isFalse = false;",
    "finally": "finally {\n\t// code\n}",
    "fixed": "fixed (int* p = &variable) {\n\t// code\n}",
    "float": "float variable = 10.5f;",
    "for": "for (int i = 0; i < ; i++) {\n\t\n}",
    "foreach": "foreach (var item in collection) {\n\t\n}",
    "goto": "goto LabelName;\nLabelName:\n\t// code",
    "if": "if () {\n\t\n}",
    "implicit": "public static implicit operator TypeName(int value) { return new TypeName(value); }",
    "in": "foreach (var item in collection) {\n\t// code\n}",
    "int": "int variable = 10;",
    "interface": "interface IInterface { void MethodName(); }",
    "internal": "internal class ClassName { }",
    "is": "if (variable is TypeName) {\n\t// code\n}",
    "lock": "lock (lockObject) {\n\t// code\n}",
    "long": "long variable = 100000L;",
    "namespace": "namespace NamespaceName {\n\tclass ClassName { }\n}",
    "new": "var variable = new TypeName();",
    "null": "object variable = null;",
    "object": "object variable = new object();",
    "operator": "public static TypeName operator +(TypeName a, TypeName b) { return new TypeName(); }",
    "out": "public void Method(out int result) { result = 10; }",
    "override": "public override void MethodName() { }",
    "params": "public void Method(params int[] values) { }",
    "partial": "partial class ClassName { }",
    "private": "private int variable;",
    "protected": "protected int variable;",
    "public": "public int variable;",
    "readonly": "readonly int variable;",
    "ref": "public void Method(ref int value) { }",
    "return": "return value;",
    "sbyte": "sbyte variable = -10;",
    "sealed": "sealed class ClassName { }",
    "short": "short variable = 10;",
    "sizeof": "int size = sizeof(int);",
    "stackalloc": "int* array = stackalloc int[10];",
    "static": "static int variable;",
    "string": "string variable = \"Hello, World!\";",
    "struct": "struct StructName { public int Field; }",
    "switch": "switch (variable) {\n\tcase value:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n}",
    "this": "this.MethodName();",
    "throw": "throw new Exception(\"Error\");",
    "true": "bool isTrue = true;",
    "try": "try {\n\t// code\n}",
    "typeof": "Type type = typeof(TypeName);",
    "uint": "uint variable = 10U;",
    "ulong": "ulong variable = 100000UL;",
    "ushort": "ushort variable = 10;",
    "using": "using (var resource = new Resource()) {\n\t// code\n}",
    "virtual": "public virtual void MethodName() { }",
    "void": "public void MethodName() { }",
    "volatile": "volatile int variable;",
    "while": "while (condition) {\n\t\n}",
    "yield": "public IEnumerable<TypeName> MethodName() {\n\tyield return new TypeName();\n}",
    "trycatch": "try {\n\t\n}\ncatch (Exception ex) {\n\t\n}",
    "constructor": "public ClassName() {}\npublic ClassName(int param) {}",
    "destructor": "~ClassName() {}",
    "property": "public Type PropertyName { get; set; }",
    "indexer": "public Type this[int index] { get { return _items[index]; } set { _items[index] = value; } }",
    "method": "public ReturnType MethodName(ParameterType parameter) { return default(ReturnType); }",
    "interfaceImplementation": "public class ClassName : IInterface { public void MethodName() {} }",
    "eventHandler": "public event EventHandler<EventArgs> EventName;\n\nprotected virtual void OnEventName(EventArgs e)\n{\n\tEventName?.Invoke(this, e);\n}",
    "disposePattern": "public void Dispose()\n{\n\tDispose(true);\n\tGC.SuppressFinalize(this);\n}\n\nprotected virtual void Dispose(bool disposing)\n{\n\tif (disposing)\n\t{\n\t\t// free managed resources\n\t}\n\t// free unmanaged resources\n}",
    "finalizePattern": "protected override void Finalize()\n{\n\tDispose(false);\n\tbase.Finalize();\n}",
    "staticConstructor": "static ClassName()\n{\n\t\n}",
    "expressionBodiedPropertyGet": "public Type PropertyName => _field;",
    "expressionBodiedPropertySet": "public Type PropertyName\n{\n\tset => _field = value;\n}",
    "fieldInitializer": "private Type _field = new Type();",
    "constructorWithParameters": "public ClassName(Type param)\n{\n\t_field = param;\n}",
    "indexInitializer": "public ClassName()\n{\n\t_items[0] = new Item();\n}",
    "explicitConversion": "public static explicit operator Type(OtherType other)\n{\n\treturn new Type();\n}",
    "implicitConversion": "public static implicit operator Type(OtherType other)\n{\n\treturn new Type();\n}",
    "operatorOverload": "public static ClassName operator +(ClassName a, ClassName b)\n{\n\treturn new ClassName();\n}",
    "indexerUsage": "var item = collection[index];",
    "delegateInvocation": "DelegateName del = () => { };\n\ndel();",
    "eventSubscription": "EventName += EventHandlerMethod;",
    "eventUnsubscription": "EventName -= EventHandlerMethod;",
    "enumValue": "var value = EnumName.Value1;",
    "enumParsing": "var value = (EnumName)Enum.Parse(typeof(EnumName), \"Value1\");",
    "enumFlags": "[Flags] public enum EnumName { Flag1 = 1, Flag2 = 2 }",
    "stringToDateTime": "DateTime date = DateTime.Parse(dateString);",
    "dateTimeToString": "string dateString = dateTime.ToString(\"yyyy-MM-dd\");",
    "stringToInt": "int number = int.Parse(stringNumber);",
    "intToString": "string stringNumber = number.ToString();",
    "stringToDouble": "double number = double.Parse(stringNumber);",
    "doubleToString": "string stringNumber = number.ToString();",
    "tryParseInt": "if (int.TryParse(stringNumber, out int number))\n{\n\t\n}",
    "tryParseDouble": "if (double.TryParse(stringNumber, out double number))\n{\n\t\n}",
    "defaultValue": "var value = default(Type);",
    "defaultOfNullable": "var value = default(int?);",
    "dictionaryAccess": "var value = dict[key];",
    "dictionaryTryGetValue": "if (dict.TryGetValue(key, out var value))\n{\n\t\n}",
    "listAdd": "list.Add(item);",
    "listRemove": "list.Remove(item);",
    "listContains": "if (list.Contains(item))\n{\n\t\n}",
    "listInsert": "list.Insert(index, item);",
    "listClear": "list.Clear();",
    "listSort": "list.Sort();",
    "listFind": "var item = list.Find(x => x.Condition);",
    "listFindAll": "var items = list.FindAll(x => x.Condition);",
    "dictionaryAdd": "dict.Add(key, value);",
    "dictionaryRemove": "dict.Remove(key);",
    "dictionaryContainsKey": "if (dict.ContainsKey(key))\n{\n\t\n}",
    "dictionaryContainsValue": "if (dict.ContainsValue(value))\n{\n\t\n}",
    "log": "Debug.Log()",
    "warning": "Debug.LogWarning()",
    "error": "Debug.LogError()"
}
